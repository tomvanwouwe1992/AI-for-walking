#include <OpenSim/OpenSim.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <ctime>
#include <windows.h>
#include "matrix.h"
#include "math.h"
#include <tuple>
#include "mex.h"
#include "SimTKcommon.h"

#include "SimTKmath.h"
#include "simmath/TimeStepper.h"
using namespace OpenSim;
using namespace SimTK;
using namespace std;

int find(Vector arr, double lengte, double seek)
{   int return_value;
    for (int i = 0; i < lengte; ++i)
    {
        if (arr[i] == seek) {return_value = i;}
    }
    return return_value;
}

Vector get_states(Model* osimModel, State& s) {
    
    const Vector& observation_original = s.getY();
    Vector observation(31, 0.0);
    
    observation[1] = observation_original.get(0);
    observation[2] = observation_original.get(1);
    observation[3] = observation_original.get(2);
    
    observation[4] = observation_original.get(10);
    observation[5] = observation_original.get(11);
    observation[6] = observation_original.get(12);
    
    observation[7]  = observation_original.get(3);
    observation[8]  = observation_original.get(4);
    observation[9]  = observation_original.get(5);
    observation[10] = observation_original.get(6);
    observation[11] = observation_original.get(7);
    observation[12] = observation_original.get(8);
    
    observation[13] = observation_original.get(13);
    observation[14] = observation_original.get(14);
    observation[15] = observation_original.get(15);
    observation[16] = observation_original.get(16);
    observation[17] = observation_original.get(17);
    observation[18] = observation_original.get(18);
    
    Vec3 massCenterPos = osimModel->calcMassCenterPosition(s);
    Vec3 massCenterVel = osimModel->calcMassCenterVelocity(s);
    
    observation[19] = massCenterPos.get(0);
    observation[20] = massCenterPos.get(1);
    
    observation[21] = massCenterVel.get(0);
    observation[22] = massCenterVel.get(1);
    
    const SimbodyEngine& SBE = osimModel->getSimbodyEngine();               // Get simbody engine - subclass that contains methods to provide information/calculation on the model (e.g.: calculate distance between two bodies)
    const BodySet& BS = osimModel->getBodySet();
    Vec3 &PosHEAD = Vec3(0.0, 0.0, 0.0);
    Vec3 &RelPosHEAD = Vec3(0.0, 0.0, 0.0);
    SBE.getPosition(s, BS.get("head"), RelPosHEAD, PosHEAD);
    
    observation[23] = PosHEAD.get(0);
    observation[24] = PosHEAD.get(1);
    
    Vec3 &PosPELVIS = Vec3(0.0, 0.0, 0.0);
    SBE.getPosition(s, BS.get("pelvis"), RelPosHEAD, PosPELVIS);
    observation[25] = PosPELVIS.get(0);
    observation[26] = PosPELVIS.get(1);
    
    Vec3 &PosTOESR = Vec3(0.0, 0.0, 0.0);
    SBE.getPosition(s, BS.get("toes_r"), RelPosHEAD, PosTOESR);
    observation[27] = PosTOESR.get(0);
    observation[28] = PosTOESR.get(1);
    
    Vec3 &PosTOESL = Vec3(0.0, 0.0, 0.0);
    SBE.getPosition(s, BS.get("toes_r"), RelPosHEAD, PosTOESL);
    observation[29] = PosTOESL.get(0);
    observation[30] = PosTOESL.get(1);
    
    return observation;
}

Vector NN_controller(Vector inputs,  std::tuple<Vector,Vector,Vector> nodegenes, std::tuple<Vector,Vector,Vector,Vector>  connectiongenes, Vector NN_info){
    
    double change_treshold = 0.001;
    int number_of_inputnodes = NN_info[0];
    int number_of_outputnodes = NN_info[1];
    
    int number_of_hiddennodes = NN_info[2];
    int number_of_connections = NN_info[3];
    int no_change_count=0;
    int index_loop=0;
    
    Vector output_signal(number_of_outputnodes, 0.0);
    
    Vector nodegenes_ID = get<0>(nodegenes);
    Vector nodegenes_input = get<1>(nodegenes);
    Vector nodegenes_output = get<2>(nodegenes);
    Vector connectiongenes_from = get<0>(connectiongenes);
    Vector connectiongenes_to = get<1>(connectiongenes);
    Vector connectiongenes_weight = get<2>(connectiongenes);
    Vector connectiongenes_enabled = get<3>(connectiongenes);
    
    
    for (int i = number_of_inputnodes + 1; i < number_of_inputnodes + number_of_outputnodes + number_of_hiddennodes + 1; i++){nodegenes_input[i] = 0;}
    nodegenes_input[number_of_inputnodes] = 1;
    
    for (int i = 0; i < number_of_inputnodes; i++){nodegenes_input[i] = inputs[i];}
    
    for(int i = 0; i < number_of_inputnodes + 1; i++){nodegenes_output[i] = nodegenes_input[i];}
    
    for (int i = number_of_inputnodes + 1; i < number_of_inputnodes + number_of_outputnodes + number_of_hiddennodes + 1; i++){nodegenes_output[i] = 1 / (1 + exp(-4.9 * nodegenes_input[i]));}
    
    Vector vector_node_state = nodegenes_output;
    double ID_connection_from_node;
    double ID_connection_to_node;
    double connection_weight;
    int index_connection_from_node;
    int index_connection_to_node;
    
    
    int checkchanges = number_of_inputnodes + number_of_outputnodes + number_of_hiddennodes + 1;
    
    while ((no_change_count<checkchanges) && index_loop<3*number_of_connections ) {
        
        index_loop++;
        vector_node_state = nodegenes_output;
        
        for (int i = 0; i < number_of_connections; i++){
            
            ID_connection_from_node = connectiongenes_from[i];
            ID_connection_to_node = connectiongenes_to[i];
            connection_weight = connectiongenes_weight[i];
            
            index_connection_from_node = find(nodegenes_ID, number_of_inputnodes+number_of_outputnodes+number_of_hiddennodes+1, ID_connection_from_node);
            
            index_connection_to_node   = find(nodegenes_ID, number_of_inputnodes+number_of_outputnodes+number_of_hiddennodes+1, ID_connection_to_node);
            
            if (connectiongenes_enabled[i] == 1){
                nodegenes_input[index_connection_to_node] = nodegenes_input[index_connection_to_node] + nodegenes_output[index_connection_from_node] * connection_weight;
            }
        }
        for (int j = number_of_inputnodes + 1; j < number_of_inputnodes+ 1 + number_of_hiddennodes + number_of_outputnodes; j++){ nodegenes_output[j] = 1 / (1 + exp(-4.9 * nodegenes_input[j]));}
        
        for (int j = number_of_inputnodes + 1; j < number_of_inputnodes+ 1 + number_of_hiddennodes + number_of_outputnodes; j++){nodegenes_input[j] = 0;}
        
        no_change_count = 0;
        for (int j = 0; j < number_of_inputnodes+ 1 + number_of_hiddennodes + number_of_outputnodes; j++)
        {
            if (nodegenes_output[j] - vector_node_state[j] < change_treshold){no_change_count++;}
        }
       
    }
    
    for (int i = 0; i < number_of_outputnodes; i++){output_signal[i] = nodegenes_output[number_of_inputnodes + 1 + i];}
    
    return output_signal;
}

tuple<double,bool> Penalty_Calc(Vector observation) {
    
    double penalty = observation[19] + observation[21];
    bool stop_integration;
    if (observation[3] < 0.80) {stop_integration = true;}
    if (observation[5] < 0.00) {stop_integration = true;}
    
    else stop_integration = false;
    
    std::tuple <double,bool> penalty_break;
    penalty_break = std::make_tuple(penalty,stop_integration);
    
    return penalty_break;
}



class MyPeriodicController : public PeriodicEventHandler {
public:
    MyPeriodicController(Real eventinterval, Model* osimModel, tuple<tuple<Vector,Vector,Vector>,tuple<Vector,Vector,Vector,Vector>,Vector> NN_STRUCTURE ) : PeriodicEventHandler(eventinterval), model(osimModel), NN_structure(NN_STRUCTURE)  {
    }
    void handleEvent(State& state, Real accuracy, bool& shouldTerminate) const {
        
        Vector states = get_states(model,  state);
        
        std::tuple<double, bool> result_penalty = Penalty_Calc(states);
        shouldTerminate = get<1>(result_penalty);
        //double cost = get<0>(result_penalty);
           
        Vector activation_vector = NN_controller(states, get<0>(NN_structure), get<1>(NN_structure), get<2>(NN_structure));
        
        Vector& activations = state.updZ();
        
        for (int i = 0; i < 18; i++){ 
            if (activation_vector[i] > 0.99)  { activation_vector[i] = 0.99;}
            if (activation_vector[i] < 0.01)  { activation_vector[i] = 0.01;}
            
            activations[2*i] = activation_vector[i];}       
    }
private:
    Model* model;
    tuple<tuple<Vector,Vector,Vector>,tuple<Vector,Vector,Vector,Vector>,Vector> NN_structure;
};

void main(double* TimeVec, Model* osimModel, double* cost_function, std::tuple<Vector,Vector,Vector> nodegenes,std::tuple<Vector,Vector,Vector,Vector> connectiongenes, Vector NN_info)
{
    
    std::tuple<tuple<Vector,Vector,Vector>,tuple<Vector,Vector,Vector,Vector>,Vector> NN_structure = make_tuple(nodegenes, connectiongenes, NN_info);
    // ******************** SimBodyLand***********************//
    osimModel->buildSystem();
    Real eventinterval = 0.01;
    MultibodySystem& system_ref = osimModel->updMultibodySystem();
    MyPeriodicController* myPeriodicController = new MyPeriodicController(eventinterval, osimModel, NN_structure);
    system_ref.addEventHandler(myPeriodicController);
    
    // ******************** OpenSimLand***********************//
    State& s = osimModel->initializeState();
        
    double initialTime;
    double finalTime;
    initialTime = TimeVec[0]; finalTime = TimeVec[1];
    
    osimModel->equilibrateMuscles(s);
    osimModel->getMultibodySystem().realize(s, Stage::Velocity);
    
    RungeKuttaMersonIntegrator integrator(osimModel->getMultibodySystem());     //Initialize integrator (RungeKuttaMerson-type)
    integrator.setAccuracy(1e-5);
    Manager manager(*osimModel, integrator);
    manager.setInitialTime(initialTime);                                        //Set initial and final times of the manager
    manager.setFinalTime(finalTime);
    manager.integrate(s);
    Storage output_storage = manager.getStateStorage();                     //Store&Output of the states as .sto-file
    Array<double> end_state = output_storage.getLastStateVector()->getData();
    //output_storage.print("output_1.sto");
    double cost = end_state[1];
    
    cost_function[0] = cost;
    return;
}

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //	OPEN Model
    
    char *osimFileName_ptr;
    osimFileName_ptr = mxArrayToString(prhs[0]);
    std::string osimFileName = std::string(&osimFileName_ptr[0]);
    
        
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //	IMPORT timevector
    double *TimeVec; double time_instants; const int *dimTime;
    TimeVec = mxGetPr(prhs[1]);
    dimTime = mxGetDimensions(prhs[1]);
    time_instants = *(dimTime + 1);
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //	IMPORT neural-network == CONTROLLER
    double *nodegenes_ptr;
    double *connectiongenes_ptr;
    const int *dim_nodegenes; const int *dim_connectiongenes;
    
    dim_nodegenes = mxGetDimensions(prhs[2]);
    int n_nodes = *(dim_nodegenes+1);
    int n_rows = *(dim_nodegenes+0);
    nodegenes_ptr = mxGetPr(prhs[2]);
    
    
    Vector IDs    = Vector(n_nodes, 0.0);
    Vector input  = Vector(n_nodes, 0.0);
    Vector output = Vector(n_nodes, 0.0);
    
    for (int j = 0; j < n_nodes; j++)
    {
        IDs[j] = nodegenes_ptr[j*4]; 
        input[j] = nodegenes_ptr[j*4+2 ]; 
        output[j] = nodegenes_ptr[j*4+3 ];
    }
    std::tuple<Vector,Vector,Vector> nodegenes = make_tuple(IDs, input, output);
    
    
    dim_connectiongenes = mxGetDimensions(prhs[3]);
    int n_connections = *(dim_connectiongenes+1);
    connectiongenes_ptr = mxGetPr(prhs[3]);
    
    Vector from = Vector(n_connections, 0.0);
    Vector to = Vector(n_connections, 0.0);
    Vector weight = Vector(n_connections, 0.0);
    Vector enabled = Vector(n_connections, 0.0);
    
    for (int j = 0; j < n_connections; j++)
    {
        from[j]    = connectiongenes_ptr[j*5+1]; 
        to[j]      = connectiongenes_ptr[j*5 + 2];
        weight[j]  = connectiongenes_ptr[j*5 + 3];
        enabled[j] = connectiongenes_ptr[j*5 + 4];
    }
    std::tuple<Vector,Vector,Vector,Vector> connectiongenes = make_tuple(from, to, weight, enabled);
    
    double* NN_info_ptr;
    NN_info_ptr = mxGetPr(prhs[4]);
    Vector NN_info = Vector(4, 0.0);
    NN_info[0] = NN_info_ptr[0];
    NN_info[1] = NN_info_ptr[1];
    NN_info[2] = NN_info_ptr[2];
    NN_info[3] = NN_info_ptr[3];
    
    Model model = Model(osimFileName);
    Model *osimModel = &model;
    
    
    plhs[0] = mxCreateDoubleMatrix(1, 1, mxREAL);
    double *cost_function;
    cost_function	= mxGetPr(plhs[0]);
    
    main(TimeVec, osimModel, cost_function, nodegenes, connectiongenes, NN_info);
    
    
}